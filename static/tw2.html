
<!DOCTYPE HTML>
<html lang="en">
	<head>
		<title>three.js canvas - interactive - cubes tween</title>
		<meta charset="utf-8">
		<style type="text/css">
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
		</style>
	</head>
	<body>
		<div id="ctrl">

		<script type="text/javascript" src="Three.js"></script>

		<script type="text/javascript" src="js/Tween.js"></script>
		<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
		<script type="text/javascript" src="js/Stats.js"></script>

		<script type="text/javascript">
			var MicroCache	= function(){
				var _values	= {};
				return {
					get	: function(key){ return _values[key];	},
					contains: function(key){ return key in _values;	},
					remove	: function(key){ delete _values[key];	},
					set	: function(key, value){	_values[key] = value;},
					values	: function(){ return _values;	},
					getSet	: function(key, value){
						if( !this.contains(key) ){
							this.set(key, typeof value == 'function' ? value() : value )
						}
						return this.get(key);
					}
				}
			}
			
			
			// export in common js
			if( typeof module !== "undefined" && ('exports' in module)){
				module.exports	= MicroCache;
			}
			var container, stats;
			var camera, scene, projector, renderer;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.Camera( 60, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.z = 1500;
				camera.position.y = 500;
				camera.position.x = 500;
				
				camera.useTarget = false;

				scene = new THREE.Scene();



				projector = new THREE.Projector();

				renderer = new THREE.WebGLRenderer();
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.microCache  = new MicroCache();
				
				var material = new THREE.MeshNormalMaterial();
				var material2 = new THREE.MeshBasicMaterial({ map: createCanvasTexture("1"), wireFrame:true});
				
				var materials = [
					[new THREE.MeshBasicMaterial({ map: createCanvasTexture("2"), wireFrame:true})],
					[],
					[new THREE.MeshBasicMaterial({ map: createCanvasTexture("3"), wireFrame:true})],
					[],
					[new THREE.MeshBasicMaterial({ map: createCanvasTexture("1"), wireFrame:true})],
					[]
				];
				x = 0;
				y = 0;
				z = 0;
				var geometry = new THREE.CubeGeometry( 200, 75, 100,1, 1, 1, materials );
				group = new THREE.Object3D();
				for ( var h = 0; h < 6; h ++ ) {
					for ( var i = 0; i < 10; i ++ ) {
		
						var object = new THREE.Mesh( geometry,  new THREE.MeshFaceMaterial() );
						object.position.x = x;
						object.position.y = y;
						object.position.z = z;

						x += 210;
						if( i % 10 == 0){
							y += 76;
							x = 0;
						}
						scene.addObject( object );
		
					}
					x = 0;
					y = 0;
					z -= 110;
				}
				
				container.appendChild(renderer.domElement);
				scene.addObject( group );
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				document.addEventListener( 'mousedown', onDocumentMouseDown, false );

			}
			
			function createCanvasTexture(text){
				var canvas2  	     = document.createElement("canvas");
				//canvas2.id   	     = "number";
				canvas2.style.width  = "200px";
				//anvas2.style.height = "200px";
				var context  	  = canvas2.getContext("2d");
				var x = canvas2.width / 2; 
				var y = canvas2.height / 2;
				context.font 	  = "32pt Arial";
				context.fillStyle = "#ff0000";
				context.fillRect(0,0,0,0);
	
		     	context.fillRect(0,0,600,600);
				context.fillStyle = "black";
				context.fillText(text, x, y);
			 	context.save();
				
				document.body.appendChild( canvas2 );
			  	//texture = new THREE.Texture( canvas2 );
				//texture = renderer.microCache.getSet('heavy', canvas2);
				
				strDataURI = canvas2.toDataURL("image/jpeg");
				img = new Image();
				img.src = strDataURI;
				//var mesh = new THREE.MeshBasicMaterial( { map: THREE.ImageUtils.loadTexture( img.src ) } );
				texture = renderer.microCache.getSet(text, THREE.ImageUtils.loadTexture(img.src));
				texture.needsUpdate = true;
				
				document.body.appendChild( canvas2 );
				return  texture;			
			}

			function onDocumentMouseDown( event ) {

				event.preventDefault();

				var vector = new THREE.Vector3( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1, 0.5 );
				projector.unprojectVector( vector, camera );

				var ray = new THREE.Ray( camera.position, vector.subSelf( camera.position ).normalize() );

				var intersects = ray.intersectScene( scene );

				if ( intersects.length > 0 ) {

					new TWEEN.Tween( intersects[ 0 ].object.position ).to( {
						x: Math.random() * 800 - 400,
						y: Math.random() * 800 - 400,
						z: Math.random() * 800 - 400 }, 2000 )
					.easing( TWEEN.Easing.Elastic.EaseOut).start();

					new TWEEN.Tween( intersects[ 0 ].object.rotation ).to( {
						x: ( Math.random() * 360 ) * Math.PI / 180,
						y: ( Math.random() * 360 ) * Math.PI / 180,
						z: ( Math.random() * 360 ) * Math.PI / 180 }, 2000 )
					.easing( TWEEN.Easing.Elastic.EaseOut).start();

				}

				/*
				// Parse all the faces
				for ( var i in intersects ) {

					intersects[ i ].face.material[ 0 ].color.setHex( Math.random() * 0xffffff | 0x80000000 );

				}
				*/
			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				stats.update();

			}

			var radius = 600;
			var theta = 0;

			function render() {

				TWEEN.update();



				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
